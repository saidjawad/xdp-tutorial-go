# -*- SPDX-FileCopyrightText: Â©  2019 Jesper Dangaard Brouer <https://github.com/netoptimizer> and XDP-Project contrinbutors -*-
# -*- SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) -*-
# -*- fill-column: 76; -*-
#+TITLE: Tutorial: Basic02 - loading a program by name
#+OPTIONS: ^:nil

In this lesson you will see that a BPF ELF file produced by LLVM can contain
more than one XDP program, and how you can select which one to load. Complete
each of the assignments below to complete the
lesson.

Like the previous lesson, this lesson is based on [[https://github.com/xdp-project][XDP-tutorial]] series by [[https://github.com/xdp-project][XDP-Project]]. 
* Using ebpf-go

There are several Go libraries to work with eBPF. We start with ebpf-go as
it is self-contained, meaning it does not depend on any other C or Go library, 
except for the standard one. 

As we saw in previous lesson, once we compiled an eBPF program to an ELF
byte code, we have to load into the kernel and finally attach it. To 
accomplish these tasks, ebpf-go provides several go structures and 
interfaces, namely: 
 - CollectionSpec
  - ProgramSpec
  - MapSpec
  - Types
 - Collection
  - Map
  - Program 

** CollectionSpec

CollectionSpec holds an intermediate representation of the contents of
a BPF ELF file. As a single ELF byte code file may contain multiple
BPF programs and maps, they will be converted to ProramSpec and MapSpec
types. They will be members of CollectionSpe. To this end, these structures
allow you to manipulate the BPF programs, maps, and types before proceeding
to load them into kernel.

** Collection 

This structure holds references to programs and maps loaded into the kernel. 

For a more detailed description of this structure have a look at [[https://ebpf-go.dev/concepts/loader/][ebpf-go documentation]].

** Code Generated by bpf2go

As you saw in part 1 of the tutorial, apart from ELF byte code files, 
the =bfp2go= utility generates additional Go files, containing some structs and 
functions to help you load and attach the programs easier. Depending on your 
use case, you may want to use some or all of the generated code. 

** Creating an XDP Program

In file:xdp_loader.go we explore multiple ways of loading and attaching XDP 
programs. If you inspect file:xpd_kern.c, you will see that we have two XDP
programs, marked by =SEC("xdp")=.  
The function =loadAllPrograms()= accepts the program name as specified in the 
file:xdp_kern.c and returns an enclosing object holding references to the program. 
It loads ALL the programs and maps found in the ELF byte code file into the kernel. 
Finally, it searches for the program name and returns a pointer to the loaded eBPF 
program. 

The function =loadProgramCustomStruct()= achieves a similar goal, but it gives more 
control in terms of loading programs. This function relies on the developer
to declare structs such as =XdpPassFunc= and =XdpDropFunc=. You can add the 
programs and maps that you want to load to a struct and finally call the 
=LoadAndAssign()= function. 

As you may have noticed one drawback of the two previous methods is that 
the eBPF program names are "hardcoded". What if we wanted to load programs 
without "hardcoding" their names in the source code? Have a look at the 
=loadProgramByName()= This function again loads the eBPF program by name 
by modifying the =CollectionSpec=. It removes other programs and keeps the 
one passed in the arguments.  

* Assignments

** Assignment 1: Setting up your test lab

As this lesson involves loading and selecting an XDP program that simply
drops all packets (via action =XDP_DROP=), you will need to load it on a
real interface to observe what is happening. To do this, we establish a test
lab environment. In the [[file:../testenv/][testenv/]] directory you will find a script
=testenv.sh= that helps you setup a test lab based on =veth= devices and
network namespaces.

E.g. run the script like:
#+begin_example sh
$ sudo ../testenv/testenv.sh setup --name veth-basic02
Setting up new environment 'veth-basic02'
Setup environment 'veth-basic02' with peer ip fc00:dead:cafe:1::2.
#+end_example

This results in the creation of an (outer) interface named: =veth-basic02=.
You can test that the environment network is operational by pinging the peer
IPv6 address =fc00:dead:cafe:1::2= (as seen in the script output).

The *assignment* is to manually load the compiled xdp program in the ELF OBJ
file =xdp_kern_bpfel.o=, using the =xdp_loader= program in this directory.
Observe the available options you can give the xdp_loader via =--help=. Try
to select the program named =xdp_drop_func= via =--progname=, and observe
via ping that packets gets dropped.

Here are some example commands:
#+begin_example sh
sudo ./xdp_loader --help
sudo ./xdp_loader --dev veth-basic02
sudo ./xdp_loader --dev veth-basic02 --unload
sudo ./xdp_loader --dev veth-basic02 --progname xdp_drop_func
#+end_example

The testenv script also has a helper command for "load" which will use the
=xdp_loader= program in the current directory:
#+begin_example
sudo ../testenv/testenv.sh load --name veth-basic02
sudo ../testenv/testenv.sh load --name veth-basic02 -- --unload
sudo ../testenv/testenv.sh load --name veth-basic02 -- --progname xdp_drop_func
#+end_example

*** A note about: The test environment and veth packets directions
When you load an XDP program on the interface visible on your host machine,
it will operate on all packets arriving *to* that interface. And since
packets that are sent from one interface in a veth pair will arrive at the
other end, the packets that your XDP program will see are the ones sent from
*within* the network namespace (netns). This means that when you are
testing, you should do the ping from *within* the network namespace that
were created by the script.

You can "enter" the namespace manually (via =sudo ip netns exec veth-basic02
/bin/bash=) or via the script like:
#+begin_example
$ sudo ../testenv/testenv.sh enter --name veth-basic02
# ping fc00:dead:cafe:1::1
#+end_example

To make this ping connectivity test easier, the script also has a =ping=
command that pings from within the netns:
#+begin_example
$ sudo ../testenv/testenv.sh ping --name veth-basic02
#+end_example

You should note that, the *cool thing* about using netns as a testlab is
that we can still "enter" the netns even-when XDP is dropping all packets.

*** Recommended: Create an alias for testenv.sh

To have faster access to the testenv.sh script, we recommend that you create
a shell alias (called =t=). The testenv script even has a command helper
for this purpose:

#+begin_example
$ ../testenv/testenv.sh alias
Eval this with `eval $(../testenv/testenv.sh alias)` to create shell alias
WARNING: Creating sudo alias; be careful, this script WILL execute arbitrary programs

alias t='sudo /home/fedora/git/xdp-tutorial/testenv/testenv.sh'
#+end_example

As pointed out, run:
#+begin_example
eval $(../testenv/testenv.sh alias)
#+end_example

You should now be able to run testenv commands as =t <command>= (e.g., =t
ping=). All subsequent examples will use this syntax.

*** Convenience: Skipping the environment name

The testenv script will save the last used testenv name, so in most cases
you can skip the =--name= parameter when running the script. If you don't
specify a name when you run =t setup=, a random name will be generated for
you.

You can have several active test environments at the same time, and you can
always select a specific one using the =--name= parameter. Run =t status= to
see the currently selected environment (i.e., the one that will be used if
you don't specify one with =--name=), as well as the list of all currently
active environments.

** Assignment 2: Use custom struct to load programs

Modify the file:xdp_loader.go to use =loadProgramCustomStruct()= and =loadAllPrograms()=
functions to load the programs mentioned in Assignment 1. 

** Assignment 2: Add xdp_abort program

Modify the file:xdp_loader.go to use the =loadProgramByName()= function for
loading the programs. Add a new program section "xdp_abort" in [[file:xdp_prog_kern.c]] 
that uses (returns) the XDP action =XDP_ABORTED= (and compile via =make=). Load this
new program, e.g. similar to above:

#+begin_example sh
sudo ./xdp_loader --dev veth-basic02 --unload-all
sudo ./xdp_loader --dev veth-basic02 --progname xdp_abort_func
#+end_example

*Lesson*: XDP_ABORTED is different from XDP_DROP, because it triggers the
tracepoint named =xdp:xdp_exception=.

While pinging from inside the namespace, record this tracepoint and observe
these records. E.g with perf like this:

#+begin_example sh
sudo perf record -a -e xdp:xdp_exception sleep 4
sudo perf script
#+end_example
